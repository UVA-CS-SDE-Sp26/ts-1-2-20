Documentation:

Deciphered: abcdefghijklmnopqurstuvwxyzABCDEFGHIJKLMNOPQURSTUVWXYZ1234567890
Ciphered text: bcdefghijklmnopqurstuvwxyzABCDEFGHIJKLMNOPQURSTUVWXYZ1234567890a

The text/string will be ciphered according to line 4 and my code will decipher it to line 3.
I can use the ciphered string as the key to deciphering the code by going back one character.

Call new constructor, with parameters of the real key and potentially bad key
Inside the constructor, need to validate the key
Create helper function validate, checks if its empty, duplicate letters, or missing letters. Throw exception if key is invalid

Constructor that takes in key and ciphered text
Call new Cipher(String refKey, String badKey)    

public Class Cipher

public Cipher(String refKey, String badKey)
{

validate(refKey, badKey)

}

private void validate(String ref, String key)
{
if either is null
throw exception, files null

if key is missing letters, != to length of refkey
throw exception, missing letters in key

if key has reoccuring letters, cannot map to ref
throw exception, duplciate letters in key
}


public String cipher(String cipher)
{
Loop through the ciphered string
if character in ciphered string == 'char' 
  find that char index in ciphered string
  go back by one to get deciphered char
keep looping through until string is deciphered
construct new string with the deciphered chars
return new string

if any chars don't match any of the chars in the key string, then it is whitespace so just keep it.

Only problem is wrapping to end, if deciphered string is a then it needs to be 0.
Can wrap around to get length - 1 index or use an if statement, so if the deciphered char is a, make it 0
}

Test Designs:

Test 1
Key works
Ciphered text: eph
Deciphered text: dog

Test 2
Key works
Ciphered text: WM98c
Deciphered text: VL87b

Test 3
Bad key, length !=
throw exception

Test 4
Bad key, letter occurs more than once
throw exception
